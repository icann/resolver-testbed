# -*- mode: ruby -*-
# vi: set ft=ruby :

# Require YAML module to parse the Ansible inventory configuration.
require 'yaml'

# Read the hosts configuration.
hosts_conf = YAML.load_file('ansible/hosts')

# Read the VirtualBox host configuration.
vbox_conf = YAML.load_file('ansible/host_vars/VBox-host')

# These are used in each VM inventory host_vars file for the network names.
# They are eval'ed later.
HOSTONLY_NET = vbox_conf['vbox_hostonlyif_name']
BRIDGE_NET = vbox_conf['bridge_net']
RESOLVER_INTNET = vbox_conf['resolver_intnet']
SERVER_INTNET = vbox_conf['server_intnet']

# All Vagrant configuration is done below. The "2" in Vagrant.configure
# configures the configuration version (we support older styles for
# backwards compatibility). Please don't change it unless you know what
# you're doing.
Vagrant.configure(2) do |config|
  # The most common configuration options are documented and commented below.
  # For a complete reference, please see the online documentation at
  # https://docs.vagrantup.com.

  # Disable automatic box update checking. If you disable this, then
  # boxes will only be checked for updates when the user runs
  # `vagrant box outdated`. This is not recommended.
  config.vm.box_check_update = false

  # Setup each configured VM.
  hosts_conf['all']['children']['vms'].each do |vhost, _|
    config.vm.define vhost do |h|
      vm_conf = YAML.load_file('ansible/host_vars/' + vhost)
      h.vm.box = vm_conf['box']
      h.vm.provider "virtualbox" do |v|
        v.name = vhost
        v.cpus = vm_conf['cpus']
        v.memory = vm_conf['memory']
        vm_conf['networks'].each do |n|
          a = n['vbox_arguments']
          v.customize ["modifyvm", :id, a[0], a[1], a[2], eval(a[3])]
        end
      end
      if vm_conf['extra'].nil? || vm_conf['extra'].empty?
        # Left empty for ruby's weird empty check above
      else
        vm_conf['extra'].each do |k, v|
            h.vm.instance_variable_set('@'+k, v)
        end
      end

      # Provision the network once...
      # ... first net_inline if present ...
      if vm_conf['provision']['net_inline'].nil? || vm_conf['provision']['net_inline'].empty?
        # Left empty for ruby's weird empty check above
      else
        h.vm.provision "shell", inline: vm_conf['provision']['net_inline']
      end
      # ... then net_script if present ...
      if vm_conf['provision']['net_script'].nil? || vm_conf['provision']['net_script'].empty?
        # Left empty for ruby's weird empty check above
      else
        h.vm.provision "shell", path: vm_conf['provision']['net_script']
      end
      # ... then net_playbook if present ...
      if vm_conf['provision']['net_playbook'].nil? || vm_conf['provision']['net_playbook'].empty?
        # Left empty for ruby's weird empty check above
      else
        h.vm.provision "ansible" do |ansible|
          ansible.playbook = vm_conf['provision']['net_playbook']
        end
      end
      # ... and shutdown
      h.vm.provision "shell", inline: vm_conf['provision']['shutdown_inline']
      ## Run the normal provisioning the rest of the time
      #if vm_conf['provision']['playbook'].nil? || vm_conf['provision']['playbook'].empty?
      #  # Left empty for ruby's weird empty check above
      #  # This if is still here because servers-vm has no Ansible yet.
      #else
      #  h.vm.provision "ansible", run: "always" do |ansible|
      #    ansible.playbook = vm_conf['provision']['playbook']
      #  end
      #end
    end
  end

end
